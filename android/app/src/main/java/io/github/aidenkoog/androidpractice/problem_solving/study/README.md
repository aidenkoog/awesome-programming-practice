#### Data Structure / Algorithm / Problem Solving

- Mechanism of Coding Test & etc
    - 요구사항 파악 => 설계 / 검증 => 기능 구현 => 결과 (=> 분석 및 디버깅, 설계 / 검증 이동)

- Data Structure <===> Algorithm
- 고려 사항
    - 시간 복잡도 / 공간 복잡도 / 구현 복잡도
    - 시간 복잡도와 공간 복잡도는 보통 trade-off 관계
- 자료구조: 데이터를 저장하고 관리하는 방식
    - 배열은 데이터 접근이 쉽고 링크드 리스트는 데이터 추가 삭제가 쉬움
- 진법 (2진법, 16, 10)
- 1024개 모이면 --> kb, mb 이런식
- 메모리 할당, 가장 작은 부분은 시작 주소로 설정
- 바이트, 비트 => 비트 8 -> 1 바이트
- 아스키 코드 65 A, 97 a
- 리스트: 배열, 링크드 리스트
- 빅오 표기법 (점근 표기법)
- Average case (= Worse case)
- 문제 이해 => 접근 방법 => 코드 설계 => 코드 구현*
- 시간복잡도 빅오에 데이터 크기를 넣어서 나온 값이 10의 8승을 넘으면 시간 제한 초과할 가능성 있음
- 제한 조건 보는 법
- 리스트 <-> 셋 (1,2,3) == (3,1,2) == (2,3,1)
    - 순서 중요, 셋은 순서 중요하지 않음
    - 리스트: 어레이 리스트 & 링크드 리스트
- 배열
    - 고정된 저장공간, 배열, 동적 배열 (사이즈 늘리는 것 가능)
    - 순차적인 데이터 저장
    - int arr[5] = ... <-- 연속적인 저장공간 즉 메모리 할당됨 20바이트
    - 선언 / 초기화 : 빅오 n
    - 접근 / 추가, 수정 : 빅오 1
    - 추가 시 리사이징이 일어나면 빅오 n
    - 중간에 값 추가 / 삭제 : 빅오 n
- 랜덤 액세스 (다이렉트 액세스)
    - 주소값
    - 배열은 연속적/순차적으로 저장되어 있기에 첫 주소값만 알고 있으면 어떤 인덱스에도 즉시 접근 가능
    - 이 개념이 다이렉트 액세스 또는 랜덤 액세스
    - 빅오 1의 시간 복잡도
    - 링크드 리스트는 랜덤 액세스 불가능, n번 연산 불가피하므로 빅오 n
- 동적 배열
    - 배열로 구성, 데이터 추가는 빅오 1, 배열 리사이징 (빅오 n)
    - 기존것보다 더큰 배열 생성 후 일일이 옮기고 (n) + 1, 기존 배열은 메모리에서 삭제. 기본적으로 언어는 2배 더 큰 배열을 만듬 (더블링)
    - Growth pattern (처음엔 더블링하다가 점점 커지면 더블링까지는 아니고 1.몇배 이런식으로 늘려짐)
- 문자열
    - String (java.lang.String)
    - 한 번 인스턴스 생성되면 수정 불가능
- 배열 활용
    - 반복문
    - 정렬 & 2 포인터? - nlogn 시간 복잡도?
      - 2포인터 양쪽에 포인터를 가지고 정렬을 빠르게 수행하는 방법
- 접근 방법
    - 직관적 생각 (ex. 완전탐색)
    - 극한 상황 생각
    - 알고리즘 & 자료구조 생각